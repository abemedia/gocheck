package skip_test

import (
	"go/ast"
	"go/parser"
	"go/token"
	"testing"

	"github.com/abemedia/gocheck/internal/skip"
	"golang.org/x/tools/go/analysis"
)

func TestNewFileStrategy(t *testing.T) {
	tests := []struct {
		name    string
		content string
		skip    bool
	}{
		{
			name:    "a_regular.go",
			content: "package test\ntype Regular struct {\n\tField string\n}",
			skip:    false,
		},
		{
			name:    "b_generated.go",
			content: "// Code generated by tool. DO NOT EDIT.\npackage test\ntype Generated1 struct {\n\tField string\n}",
			skip:    true,
		},
		{
			name:    "c_regular2.go",
			content: "package test\ntype Regular2 struct {\n\tField string\n}",
			skip:    false,
		},
		{
			name:    "d_generated2.go",
			content: "// Code generated by another tool. DO NOT EDIT.\npackage test\ntype Generated2 struct {\n\tField string\n}",
			skip:    true,
		},
	}

	pass := &analysis.Pass{Fset: token.NewFileSet(), Files: make([]*ast.File, len(tests))}
	for i, tf := range tests {
		var err error
		pass.Files[i], err = parser.ParseFile(pass.Fset, tf.name, tf.content, parser.ParseComments)
		if err != nil {
			t.Fatalf("Failed to parse %s: %v", tf.name, err)
		}
	}

	nodeFilter := skip.NewFileStrategy(pass, ast.IsGenerated)

	for i, tf := range tests {
		if got := nodeFilter(pass.Files[i].Decls[0]); got != tf.skip {
			t.Errorf("nodeFilter(%q) = %v, expected %v", tf.name, got, tf.skip)
		}
	}
}
